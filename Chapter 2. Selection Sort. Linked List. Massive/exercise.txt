1. Допустим вы используете приложения для ведения финансов. Каждый день записываете расходы и доходы и в конце
месяца считаете сколько и на что было у вас потрачено денег. В таком приложении чаще используется функция вставки,
нежели чтения. Какой способ хранения данных будет более оптимален? - Связные списки

2. Вы пишите приложение для приёма заказов. Официант добавляет заказы в список, а повара читают заказ и начинают
готовить. Заказы образуют очередь, официант добавляет заказ в конец очереди, а повар начинает с первого заказа. Какая
структура данных будет более оптимальна для использования? - Я думаю, что связные списки. Повар всегда будет готовить 1
элемент заказа, затем приступать к следующему, то есть по сути он удаляет элемент из всего списка, никак не задевая
остальные элементы. Тут главное, что главная обязанность повара - готовить. Поэтому он убирает по 1 элементу из списка.
Если бы ему было важно просто смотреть и проверять элементы в желаемом ему произвольном порядке, то тогда - можно было
бы использовать массивы.

3. Представим, что в фейсбук заходит пользователь и программе нужно проверить есть ли данный пользователь в списке
всех пользователей соц. сети. Допустим система ищет пользователя по имени используя бинарный поиск, которому необходим
произвольный доступ, чтобы получить средний элемент. Какую структуру данных вы бы использовали? - Тут сильная подсказка
в том, что программе нужен произовльный доступ, да и к тому же, чтобы найти определенного пользователя по связному
списку, то нужно будет пройтись по всвем элементам, что очень затруднительно

4. Предположим, вы используете массив для хранения всех пользователей Фейсбук. Какими недостатками обладает массив для
выполнения вставки? Что произойдет при добавлении новых пользователей в массив, при использовании бинарного поиска?
- Допустим если делать вставку 1001-ого пользователя в середину или куда либо, то придётся смещать всех остальных
пользователей вниз по списку. Если же добавлять с конца, то придётся найти новую ячейку памяти, при которой будет
достаточно места для всех пользователей и еще надо будет их переместить.
